- name: upgrade systems
  # upgrade packages, kernels, reboot if necesssary / use icinga API calls to schedule downtime and force service checks
  hosts: production
  become: yes
  serial: 1
  vars:
    icinga_server: vmware-icinga2
    ansible_port: 22

  tasks:

  # do an "apt-get update" to get latest package lists
  - name: do an "apt-get update"
    apt:
      update-cache: yes
    changed_when: 0

  # get a list of packages that have updates
  - name: get list of pending updates "apt-get --simulate dist upgrade"
    command: apt-get --simulate dist-upgrade
    args:
      warn: false  # don't warn us about apt having its own plugin
    register: apt_simulate
    changed_when: 0

  # pick out list of pending updates from command output
  - name: parse "apt-get" output list of changed packages
    set_fact:
      updates: '{{ apt_simulate.stdout_lines | select("match", "^Inst ") | list | sort }}'
    changed_when: 0
 
  # tell user about packages being updated
  - name: show pending updates
    debug:
      var: updates
    when: updates.0 is defined

  # comment this out to bypass manually ack updates for hosts
  - pause:
    when: updates.0 is defined

  # if a new kernel is incoming, remove old ones to avoid full /boot
  - name: apt-get autoremove
    command: apt-get -y autoremove
    args:
      warn: false
    when: '"Inst linux-image-" in apt_simulate.stdout'
    changed_when: 0
 
  # do the actual apt-get upgrade, decided to play safe and not do dist-upgrade which may remove packages
  - name: apt-get upgrade
    apt:
      upgrade: yes
    register: upgrade_output

  # icinga api call to reschedule-check for hosts 'APT Updates' to bring things back into the green
  - name: reschedule-check for host service on icinga2 via api
    uri:
      url: 'https://{{icinga_server}}:5665/v1/actions/reschedule-check'
      user: root
      password: icinga
      validate_certs: no
      headers:
        Accept: 'application/json'
        Content-Type: 'application/json'
      body: {"type":"Service","filter":"host.name==\"{{inventory_hostname}}\"&&service.name==\"APT Updates\"","pretty":true}
      body_format: json
      method: POST
    register: icinga_output

  - debug: var=icinga_output
  
  # check if system needs a reboot
  - name: check if reboot needed
    stat: path=/var/run/reboot-required
    register: file_reboot_required
  # "meta: end_play" aborts the rest of the tasks in the current «tasks:»
  # section, for the current host
  # "when:" clause ensures that the "meta: end_play" only triggers if the
  # current webserver does _not_ need a reboot
  - meta: end_play
    when: not file_reboot_required.stat.exists
  # because of the above meta/when we at this point know that the current
  # host needs a reboot

  # icinga api call to schedule-downtime for host, only fires if reboot is incomming.
  - name: icinga api schedule-downtime for host
    vars:
      # capture start time in seconds, now.
      start_time: "{{ ansible_date_time.epoch }}"
      # add 3 minutes to epoch time, reboot is quick in vmware
      end_time: "{{ lookup('pipe', 'date +%s --date=\"+300 seconds\"') }}"

    uri:
      url: https://{{icinga_server}}:5665/v1/actions/schedule-downtime?host={{inventory_hostname}}
      user: root
      password: icinga
      validate_certs: no
      headers:
        Accept: 'application/json'
        Content-Type: 'application/json'
      body: {"author":"mconway","comment":"Ansible scheduled downtime","start_time":"{{start_time}}","end_time":"{{end_time}}","pretty":true}
      body_format: json
      method: POST
    register: icinga_output

  - debug: var=icinga_output

  - name: reboot node
    shell: sleep 2 && shutdown -r now "Reboot triggered by ansible"
    async: 1
    poll: 0
    ignore_errors: true

  # poll ssh port until we get a tcp connect
  - name: wait for node to finish booting
    become: false
    local_action: wait_for host={{ ansible_ssh_host }}
      port={{ ansible_port }}
      state=started
      delay=30
      timeout=300

  # give sshd time to start fully
  - name: wait for ssh to start fully
    pause:
      seconds: 60

  # icinga api call reschedule-check for hosts 'Kernel Version Check' to bring things back into the green
  - name: reschedule-check for host service on icinga2 via api
    
    uri:
      url: https://{{icinga_server}}:5665/v1/actions/reschedule-check
      user: root
      password: icinga
      validate_certs: no
      headers:
        Accept: 'application/json'
        Content-Type: 'application/json'
      body: {"type":"Service","filter":"host.name==\"{{inventory_hostname}}\"&&service.name==\"Kernel Version Check\"","pretty":true}
      body_format: json
      method: POST
    register: icinga_return

  - debug: var=icinga_return

  # icinga api call to remove downtime for host
  - name: remove icinga downtime for host

    uri:
      url: https://{{icinga_server}}:5665/v1/actions/remove-downtime?host={{inventory_hostname}}
      user: root
      password: icinga
      validate_certs: no
      headers:
        Accept: 'application/json'
        Content-Type: 'application/json'
      method: POST
    register: icinga_return

  - debug: var=icinga_return

  # wait a few minutes between hosts, unless we're on the last
  - name: waiting between hosts
    pause:
      minutes: 1
    when: inventory_hostname != ansible_play_hosts[-1]
